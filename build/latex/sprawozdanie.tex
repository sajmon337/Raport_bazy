%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,openany,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Sprawozdanie}
\date{Jul 03, 2025}
\release{1.0}
\author{Mateusz Brokos, Szymon Blatkowski}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\tableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Wprowadzenie}
\label{\detokenize{rozdzial1/index:wprowadzenie}}\label{\detokenize{rozdzial1/index::doc}}
\sphinxAtStartPar
Prowadzący: Piotr Czaja

\sphinxAtStartPar
Kurs: Bazy Danych 1

\sphinxAtStartPar
Student oddający prace: Szymon Blatkowski

\sphinxAtStartPar
Celem niniejszego raportu jest szczegółowe przedstawienie procesu projektowania, implementacji oraz oceny wydajności relacyjnej bazy danych wspierającej funkcjonowanie przychodni lekarskiej. Opracowana baza danych umożliwia rejestrację pacjentów, lekarzy i wizyt, zapewniając klarowne modele danych oraz możliwość generowania raportów i analiz statystycznych. W pracy uwzględniono aspekty normalizacji struktury tabel, optymalizacji zapytań oraz przykłady wykorzystania narzędzi wspomagających dokumentowanie kodu. Raport obejmuje zarówno fazę projektową, jak i praktyczne aspekty wdrożenia rozwiązania.

\sphinxAtStartPar
W kolejnej sekcji skupimy się na pogłębianiu wiedzy na temat baz danych poprzez przeprowadzenie przeglądu literatury oraz wyciągnięcie kluczowych informacji.

\sphinxstepscope


\chapter{Przegląd literatury}
\label{\detokenize{rozdzial2/index:przeglad-literatury}}\label{\detokenize{rozdzial2/index::doc}}

\section{Wydajność, skalowanie i replikacja}
\label{\detokenize{rozdzial2/index:wydajnosc-skalowanie-i-replikacja}}\begin{quote}\begin{description}
\sphinxlineitem{Autorzy}\begin{itemize}
\item {} 
\sphinxAtStartPar
Mateusz Brokos

\item {} 
\sphinxAtStartPar
Szymon Blatkowski

\item {} 
\sphinxAtStartPar
Maciej Gołębiowski

\end{itemize}

\end{description}\end{quote}


\section{Wstęp}
\label{\detokenize{rozdzial2/index:wstep}}
\sphinxAtStartPar
Celem niniejszej pracy jest omówienie kluczowych zagadnień związanych z wydajnością, skalowaniem oraz replikacją baz danych. Współczesne systemy informatyczne wymagają wysokiej dostępności i szybkiego przetwarzania danych, dlatego odpowiednie mechanizmy replikacji i optymalizacji wydajności odgrywają istotną rolę w zapewnieniu niezawodnego działania aplikacji. Praca przedstawia różne podejścia do replikacji danych, sposoby testowania wydajności sprzętu oraz techniki zarządzania zasobami i kontrolowania dostępu użytkowników. Omówiono również praktyczne rozwiązania stosowane w popularnych systemach baz danych, takich jak MySQL i PostgreSQL.


\section{Buforowanie oraz zarządzanie połączeniami}
\label{\detokenize{rozdzial2/index:buforowanie-oraz-zarzadzanie-polaczeniami}}
\sphinxAtStartPar
Buforowanie i zarządzanie połączeniami to kluczowe mechanizmy zwiększające wydajność i stabilność systemu.


\subsection{Buforowanie połączeń:}
\label{\detokenize{rozdzial2/index:buforowanie-polaczen}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Unieważnienie (Inwalidacja) bufora: Proces usuwania nieaktualnych danych z pamięci podręcznej, aby aplikacja zawsze korzystała ze świeżych informacji. Może być wykonywana automatycznie (np. przez wygasanie danych) lub ręcznie przez aplikację.

\item {} 
\sphinxAtStartPar
Buforowanie wyników: Polega na przechowywaniu rezultatów złożonych zapytań w pamięci podręcznej, co pozwala uniknąć ich wielokrotnego wykonywania i poprawia wydajność systemu, zwłaszcza przy operacjach na wielu tabelach.

\item {} 
\sphinxAtStartPar
Zapisywanie wyników zapytań: Wyniki często wykonywanych zapytań są przechowywane w cache, dzięki czemu aplikacja może je szybko odczytać, co zmniejsza obciążenie bazy danych i przyspiesza odpowiedź.

\end{itemize}


\subsection{Zarządzanie połączeniami:}
\label{\detokenize{rozdzial2/index:zarzadzanie-polaczeniami}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Monitorowanie parametrów połączeń: Śledzenie wskaźników takich jak czas reakcji, błędy łączenia i ilość przesyłanych danych. Regularne monitorowanie pozwala szybko wykrywać i usuwać problemy, zwiększając stabilność i wydajność systemu.

\item {} 
\sphinxAtStartPar
Zarządzanie grupami połączeń: Utrzymywanie zestawu aktywnych połączeń, które mogą być wielokrotnie wykorzystywane. Ogranicza to konieczność tworzenia nowych połączeń, co poprawia wydajność i oszczędza zasoby.

\item {} 
\sphinxAtStartPar
Obsługa transakcji: Kontrola przebiegu transakcji w bazie danych w celu zapewnienia spójności i integralności danych. Wszystkie operacje w transakcji są realizowane jako jedna niepodzielna jednostka, co zapobiega konfliktom.

\end{itemize}


\section{Wydajność}
\label{\detokenize{rozdzial2/index:wydajnosc}}
\sphinxAtStartPar
Wydajność bazy danych to kluczowy czynnik wpływający na skuteczne zarządzanie danymi i funkcjonowanie organizacji. W dobie cyfrowej transformacji optymalizacja działania baz stanowi istotny element strategii IT. W tym rozdziale omówiono sześć głównych wskaźników wydajności: czas odpowiedzi, przepustowość, współbieżność, wykorzystanie zasobów, problem zapytań N+1 oraz błędy w bazie danych. Regularne monitorowanie tych parametrów i odpowiednie reagowanie zapewnia stabilność systemu i wysoką efektywność pracy. Zaniedbanie ich kontroli grozi spadkiem wydajności, ryzykiem utraty danych i poważnymi awariami.


\subsection{Klastry oraz indeksy}
\label{\detokenize{rozdzial2/index:klastry-oraz-indeksy}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Klaster w bazie danych to metoda organizacji, w której powiązane tabele są przechowywane na tym samym obszarze dysku. Dzięki relacjom za pomocą kluczy obcych dane znajdują się blisko siebie, co skraca czas dostępu i zwiększa wydajność wyszukiwania.

\item {} 
\sphinxAtStartPar
Indeks w bazie danych to struktura przypominająca spis treści, która pozwala szybko lokalizować dane w tabeli bez konieczności jej pełnego przeszukiwania. Tworzenie indeksów na kolumnach znacząco przyspiesza operacje wyszukiwania i dostępu.

\end{itemize}


\subsection{1. Współbieżność w bazach danych}
\label{\detokenize{rozdzial2/index:wspolbieznosc-w-bazach-danych}}
\sphinxAtStartPar
Współbieżność w bazach danych oznacza zdolność systemu do jednoczesnego przetwarzania wielu operacji, co ma kluczowe znaczenie tam, gdzie wielu użytkowników korzysta z bazy w tym samym czasie. Poziom współbieżności mierzy się m.in. liczbą transakcji na sekundę (TPS) i zapytań na sekundę (QPS).
\begin{description}
\sphinxlineitem{Na wysoką współbieżność wpływają:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Poziomy izolacji transakcji, które równoważą spójność danych i możliwość równoległej pracy \textendash{} wyższe poziomy izolacji zwiększają dokładność, ale mogą ograniczać współbieżność przez blokady.

\item {} 
\sphinxAtStartPar
Mechanizmy blokad, które minimalizują konflikty między transakcjami i zapewniają płynne działanie systemu.

\item {} 
\sphinxAtStartPar
Architektura systemu, zwłaszcza rozproszona, umożliwiająca rozłożenie obciążenia na wiele węzłów i poprawę skalowalności.

\end{itemize}

\sphinxlineitem{Do głównych wyzwań należą:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Hotspoty danych, czyli miejsca często jednocześnie odczytywane lub modyfikowane, tworzące wąskie gardła.

\item {} 
\sphinxAtStartPar
Zakleszczenia, gdy transakcje wzajemnie się blokują, uniemożliwiając zakończenie pracy.

\item {} 
\sphinxAtStartPar
Głód zasobów, kiedy niektóre operacje monopolizują zasoby, ograniczając dostęp innym procesom i obniżając wydajność.

\end{itemize}

\end{description}


\subsection{2. Przepustowość bazy danych}
\label{\detokenize{rozdzial2/index:przepustowosc-bazy-danych}}
\sphinxAtStartPar
Przepustowość bazy danych to miara zdolności systemu do efektywnego przetwarzania określonej liczby operacji w jednostce czasu. Im wyższa, tym więcej zapytań lub transakcji baza obsłuży szybko i sprawnie.
\begin{description}
\sphinxlineitem{Na przepustowość wpływają:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Współbieżność: Skuteczne zarządzanie transakcjami i blokadami pozwala na równoczesne operacje bez konfliktów, co jest ważne przy dużym obciążeniu (np. w sklepach internetowych).

\item {} 
\sphinxAtStartPar
Bazy NoSQL: Często stosują model ewentualnej spójności, umożliwiając szybsze zapisy bez oczekiwania na pełną synchronizację replik.

\item {} 
\sphinxAtStartPar
Dystrybuowanie danych: Techniki takie jak sharding (NoSQL) czy partycjonowanie (SQL) rozkładają dane na różne serwery, zwiększając zdolność przetwarzania wielu operacji jednocześnie.

\end{itemize}

\end{description}

\sphinxAtStartPar
Podsumowując, odpowiednie zarządzanie współbieżnością, wybór architektury i rozproszenie danych to klucz do wysokiej przepustowości bazy danych.


\subsection{3. Responsywność bazy danych}
\label{\detokenize{rozdzial2/index:responsywnosc-bazy-danych}}
\sphinxAtStartPar
Czasy odpowiedzi bazy danych są kluczowe w środowiskach wymagających szybkich decyzji, np. w finansach czy sytuacjach kryzysowych.
\begin{description}
\sphinxlineitem{Na czas reakcji bazy wpływają:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Architektura bazy: dobrze zaprojektowane partycjonowanie, indeksowanie oraz bazy działające w pamięci operacyjnej znacząco przyspieszają dostęp do danych.

\item {} 
\sphinxAtStartPar
Topologia oraz stan sieci: opóźnienia, przepustowość i stabilność sieci w systemach rozproszonych wpływają na szybkość przesyłu danych; optymalizacja i kompresja zmniejszają te opóźnienia.

\item {} 
\sphinxAtStartPar
Balansowanie obciążeń oraz dostęp równoczesny: pooling połączeń, replikacja i równoważenie obciążenia pomagają utrzymać krótkie czasy odpowiedzi przy dużym ruchu.

\end{itemize}

\end{description}

\sphinxAtStartPar
Szybkie odpowiedzi podnoszą efektywność, satysfakcję użytkowników i konkurencyjność systemu bazodanowego.


\subsection{4. Zapytania N+1}
\label{\detokenize{rozdzial2/index:zapytania-n-1}}
\sphinxAtStartPar
Problem zapytań typu N+1 to częsta nieefektywność w aplikacjach korzystających z ORM, polegająca na wykonywaniu wielu zapytań \textendash{} jednego głównego i osobnego dla każdego powiązanego rekordu. Na przykład, pobranie 10 użytkowników i osobne zapytanie o profil dla każdego daje łącznie 11 zapytań.
\begin{description}
\sphinxlineitem{Przyczyny to:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Błędna konfiguracja ORM, szczególnie „leniwe ładowanie”, powodujące nadmiar zapytań.

\item {} 
\sphinxAtStartPar
Nieoptymalne wzorce dostępu do danych, np. pobieranie danych w pętlach.

\item {} 
\sphinxAtStartPar
Niewykorzystanie złączeń SQL (JOIN), które pozwalają na pobranie danych w jednym zapytaniu.

\end{itemize}

\end{description}


\subsection{5. Błędy w bazach danych}
\label{\detokenize{rozdzial2/index:bledy-w-bazach-danych}}
\sphinxAtStartPar
Błędy wpływające na wydajność bazy danych to istotny wskaźnik kondycji systemu.
\begin{description}
\sphinxlineitem{Najczęstsze typy błędów to:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Błędy składni zapytań \textendash{} wynikają z niepoprawnej składni SQL, powodując odrzucenie zapytania.

\item {} 
\sphinxAtStartPar
Błędy połączenia \textendash{} problemy z nawiązaniem połączenia, często przez awarie sieci, błędne konfiguracje lub awarie serwera.

\item {} 
\sphinxAtStartPar
Błędy limitów zasobów \textendash{} gdy system przekracza dostępne zasoby (dysk, CPU, pamięć), co może spowalniać lub zatrzymywać działanie.

\item {} 
\sphinxAtStartPar
Naruszenia ograniczeń \textendash{} próby wstawienia danych łamiących zasady integralności (np. duplikaty tam, gdzie wymagana jest unikalność).

\item {} 
\sphinxAtStartPar
Błędy uprawnień i zabezpieczeń \textendash{} brak odpowiednich praw dostępu skutkuje odmową operacji na danych.

\end{itemize}

\sphinxAtStartPar
Skuteczna identyfikacja i usuwanie tych błędów jest kluczowa dla stabilności i wydajności bazy danych.

\end{description}


\subsection{6. Zużycie dostępnych zasobów}
\label{\detokenize{rozdzial2/index:zuzycie-dostepnych-zasobow}}
\sphinxAtStartPar
Zużycie zasobów w bazach danych to kluczowy czynnik wpływający na ich wydajność.
\begin{description}
\sphinxlineitem{Najważniejsze zasoby to:}\begin{itemize}
\item {} 
\sphinxAtStartPar
CPU: Odpowiada za przetwarzanie zapytań i zarządzanie transakcjami. Nadmierne obciążenie może wskazywać na przeciążenie lub nieoptymalne zapytania.

\item {} 
\sphinxAtStartPar
Operacje I/O na dysku: Odczyt i zapis danych. Wysoka liczba operacji może oznaczać słabe buforowanie; efektywne cache’owanie zmniejsza potrzebę częstego dostępu do dysku i eliminuje wąskie gardła.

\item {} 
\sphinxAtStartPar
Pamięć RAM: służy do przechowywania często używanych danych i buforów. Jej niedobór lub złe zarządzanie powoduje korzystanie z wolniejszej pamięci dyskowej, co obniża wydajność.

\end{itemize}

\end{description}

\sphinxAtStartPar
Dobre zarządzanie CPU, pamięcią i operacjami dyskowymi jest niezbędne dla utrzymania wysokiej wydajności i stabilności systemu bazodanowego.


\subsection{Prostota rozbudowy:}
\label{\detokenize{rozdzial2/index:prostota-rozbudowy}}
\sphinxAtStartPar
Bazy danych SQL typu scale\sphinxhyphen{}out umożliwiają liniową skalowalność przez dodawanie nowych węzłów do klastra bez przestojów i zmian w aplikacji czy sprzęcie. Każdy węzeł aktywnie przetwarza transakcje, a logika bazy jest przenoszona do tych węzłów, co ogranicza transfer danych w sieci i redukuje ruch. Tylko jeden węzeł obsługuje zapisy dla danego fragmentu danych, eliminując rywalizację o zasoby, co poprawia wydajność w porównaniu do tradycyjnych baz, gdzie blokady danych spowalniają system przy wielu operacjach jednocześnie.


\subsection{Analityka czasu rzeczywistego:}
\label{\detokenize{rozdzial2/index:analityka-czasu-rzeczywistego}}
\sphinxAtStartPar
Analityka czasu rzeczywistego w Big Data umożliwia natychmiastową analizę danych, dając firmom przewagę konkurencyjną. Skalowalne bazy SQL pozwalają na szybkie przetwarzanie danych operacyjnych dzięki technikom działającym w pamięci operacyjnej i wykorzystującym szybkie dyski SSD, bez potrzeby stosowania skomplikowanych rozwiązań. Przykłady Google (baza F1 SQL w Adwords) i Facebooka pokazują, że relacyjne bazy danych są efektywne zarówno w OLTP, jak i OLAP, a integracja SQL z ekosystemem Hadoop zwiększa możliwości analityczne przy jednoczesnym ograniczeniu zapotrzebowania na specjalistów.


\subsection{Dostępność w chmurze:}
\label{\detokenize{rozdzial2/index:dostepnosc-w-chmurze}}
\sphinxAtStartPar
Organizacje wymagają nieprzerwanej pracy aplikacji produkcyjnych, co zapewnia ciągłość procesów biznesowych. W przypadku awarii chmury szybkie przywrócenie bazy danych bez utraty danych jest kluczowe. Skalowalne bazy SQL realizują to poprzez mechanizmy wysokiej dostępności, które opierają się na replikacji wielu kopii danych, minimalizując ryzyko ich utraty.


\subsection{Unikanie wąskich gardeł:}
\label{\detokenize{rozdzial2/index:unikanie-waskich-gardel}}
\sphinxAtStartPar
W skalowalnych bazach danych SQL rozwiązano problem logu transakcyjnego, który w tradycyjnych systemach często stanowił wąskie gardło wydajności. W klasycznych rozwiązaniach wszystkie rekordy muszą być najpierw zapisane w logu transakcyjnym przed zakończeniem zapytania. Niewłaściwa konfiguracja lub awarie mogą powodować nadmierne rozrosty logu, czasem przekraczające rozmiar samej bazy, co skutkuje znacznym spowolnieniem operacji zapisu, nawet przy użyciu szybkich dysków SSD.


\section{Skalowanie}
\label{\detokenize{rozdzial2/index:skalowanie}}
\sphinxAtStartPar
Bazy danych SQL nie są tak kosztowne w rozbudowie, jak się często uważa, ponieważ oferują możliwość skalowania poziomego. Ta cecha jest szczególnie cenna w analizie danych biznesowych, gdzie rośnie potrzeba przetwarzania danych klientów z wielu źródeł w czasie rzeczywistym. Obok tradycyjnych rozwiązań dostępne są również bazy NoSQL, NewSQL oraz platformy oparte na Hadoop, które odpowiadają na różne wyzwania związane z przetwarzaniem dużych ilości danych. Skalowanie poziome z optymalnym balansem pomiędzy pamięcią RAM a pamięcią flash pozwala osiągnąć wysoką wydajność. Przykłady nowoczesnych skalowalnych baz SQL, takich jak InfiniSQL, ClustrixDB czy F1, potwierdzają, że tradycyjne bazy SQL mogą efektywnie skalować się wszerz.


\section{Replikacja}
\label{\detokenize{rozdzial2/index:replikacja}}
\sphinxAtStartPar
Replikacja danych to proces kopiowania informacji między różnymi serwerami baz danych, który przynosi wiele korzyści:
\sphinxhyphen{} Zwiększenie skalowalności \textendash{} obciążenie systemu jest rozdzielane między wiele serwerów; zapisy i aktualizacje odbywają się na jednym serwerze, natomiast odczyty i wyszukiwania na innych, co poprawia wydajność.
\sphinxhyphen{} Poprawa bezpieczeństwa \textendash{} tworzenie kopii bazy produkcyjnej pozwala chronić dane przed awariami sprzętu, choć nie zabezpiecza przed błędnymi operacjami wykonywanymi na bazie (np. DROP TABLE).
\sphinxhyphen{} Zapewnienie separacji środowisk \textendash{} kopia bazy może być udostępniona zespołom programistycznym i testerskim, umożliwiając pracę na izolowanym środowisku bez ryzyka wpływu na bazę produkcyjną.
\sphinxhyphen{} Ułatwienie analizy danych \textendash{} obciążające analizy i obliczenia mogą być wykonywane na oddzielnym serwerze, dzięki czemu nie obciążają głównej bazy danych i nie wpływają na jej wydajność.


\subsection{Mechanizmy replikacji}
\label{\detokenize{rozdzial2/index:mechanizmy-replikacji}}
\sphinxAtStartPar
Replikacja w bazach danych polega na kopiowaniu i synchronizowaniu danych oraz obiektów z serwera głównego (master) na serwer zapasowy (slave), aby zapewnić spójność i wysoką dostępność danych.

\sphinxAtStartPar
Mechanizm replikacji MySQL działa w następujący sposób:
\sphinxhyphen{} Serwer główny zapisuje wszystkie zmiany w plikach binarnych (bin\sphinxhyphen{}logach), które zawierają instrukcje wykonane na masterze.
\sphinxhyphen{} Specjalny wątek na masterze przesyła bin\sphinxhyphen{}logi do serwerów slave.
\sphinxhyphen{} Wątek SQL, który odczytuje relay\sphinxhyphen{}logi i wykonuje zapisane w nich zapytania, aby odtworzyć zmiany w lokalnej bazie.
\sphinxhyphen{} Wątek I/O, który odbiera bin\sphinxhyphen{}logi i zapisuje je do relay\sphinxhyphen{}logów (tymczasowych plików na slave).
Podsumowując, replikacja w MySQL polega na automatycznym przesyłaniu i odtwarzaniu zmian, dzięki czemu baza na serwerze zapasowym jest na bieżąco synchronizowana z bazą główną.


\subsection{Rodzaje mechanizmów replikacji}
\label{\detokenize{rozdzial2/index:rodzaje-mechanizmow-replikacji}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Replikacja oparta na zapisie (Write\sphinxhyphen{}Ahead Logging): Ten typ replikacji jest często wykorzystywany w systemach takich jak PostgreSQL. Polega na tym, że zmiany w transakcjach są najpierw zapisywane w dzienniku zapisu, a następnie jego zawartość jest kopiowana na serwery repliki.

\item {} 
\sphinxAtStartPar
Replikacja oparta na zrzutach (Snapshot\sphinxhyphen{}Based Replication): W niektórych systemach stosuje się okresowe tworzenie pełnych zrzutów bazy danych, które są przesyłane do serwerów repliki.

\item {} 
\sphinxAtStartPar
Replikacja oparta na transakcjach (Transaction\sphinxhyphen{}Based Replication): W tym modelu każda transakcja jest przekazywana i odtwarzana na serwerach repliki, co sprawdza się w systemach wymagających silnej spójności.

\item {} 
\sphinxAtStartPar
Replikacja asynchroniczna i synchroniczna: W replikacji asynchronicznej dane najpierw trafiają do głównej bazy, a potem na repliki. W replikacji synchronicznej zapisy są wykonywane jednocześnie na serwerze głównym i replikach.

\item {} 
\sphinxAtStartPar
Replikacja dwukierunkowa (Bi\sphinxhyphen{}Directional Replication): Pozwala na wprowadzanie zmian na dowolnym z serwerów repliki, które są synchronizowane z pozostałymi, co jest szczególnie użyteczne w systemach o wysokiej dostępności.

\end{itemize}

\sphinxAtStartPar
PostgreSQL oferuje różne metody replikacji, w tym opartą na zapisie (WAL), asynchroniczną, synchroniczną oraz replikację logiczną. Mechanizm WAL zapewnia bezpieczeństwo danych przez zapisywanie wszystkich zmian w dzienniku przed ich zastosowaniem i przesyłanie go na repliki. W trybie asynchronicznym dane trafiają najpierw na serwer główny, a potem na repliki, natomiast w trybie synchronicznym zapisy są realizowane jednocześnie. Dodatkowo, replikacja logiczna umożliwia kopiowanie wybranych tabel lub baz, co jest przydatne w przypadku bardzo dużych zbiorów danych.


\subsection{Zalety i Wady replikacji}
\label{\detokenize{rozdzial2/index:zalety-i-wady-replikacji}}
\sphinxAtStartPar
Zalety:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Zwiększenie wydajności i dostępności: Replikacja pozwala rozłożyć obciążenie zapytań na wiele serwerów, co poprawia wydajność systemu. Użytkownicy mogą kierować zapytania do najbliższych serwerów repliki, skracając czas odpowiedzi. W przypadku awarii jednego serwera pozostałe repliki kontynuują obsługę zapytań, zapewniając wysoką dostępność.

\item {} 
\sphinxAtStartPar
Ochrona danych: Replikacja wspiera tworzenie kopii zapasowych i odzyskiwanie danych. W razie awarii głównej bazy replika może służyć jako źródło do odtworzenia informacji.

\item {} 
\sphinxAtStartPar
Rozproszenie danych geograficzne: Umożliwia przenoszenie danych do różnych lokalizacji. Międzynarodowa firma może replikować dane między oddziałami, co pozwala lokalnym użytkownikom na szybki dostęp.

\item {} 
\sphinxAtStartPar
Wsparcie analizy i raportowania: Dane z replik mogą być wykorzystywane do analiz i raportów, co odciąża główną bazę danych i utrzymuje jej wysoką wydajność.

\end{itemize}

\sphinxAtStartPar
Wady:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Replikacja nie gwarantuje, że po wykonaniu operacji dane na serwerze głównym zostaną w pełni odzwierciedlone na serwerze zapasowym.

\item {} 
\sphinxAtStartPar
Mechanizm nie chroni przed skutkami działań, takich jak przypadkowe usunięcie tabeli (DROP TABLE).

\end{itemize}


\section{Kontrola dostępu i limity systemowe}
\label{\detokenize{rozdzial2/index:kontrola-dostepu-i-limity-systemowe}}
\sphinxAtStartPar
Limity systemowe w zarządzaniu bazami danych określają maksymalną ilość zasobów, które system jest w stanie obsłużyć. Są one ustalane przez system zarządzania bazą danych (DBMS) i zależą od zasobów sprzętowych oraz konfiguracji. Na przykład w Azure SQL Database limity zasobów różnią się w zależności od wybranego poziomu cenowego. W MySQL maksymalny rozmiar tabeli jest zwykle ograniczony przez parametry systemu operacyjnego dotyczące wielkości plików.

\sphinxAtStartPar
Kontrola dostępu użytkowników w DBMS to mechanizm umożliwiający lub blokujący dostęp do danych. Składa się z dwóch elementów: uwierzytelniania, czyli potwierdzania tożsamości użytkownika, oraz autoryzacji, czyli ustalania jego uprawnień. Wyróżnia się modele takie jak Kontrola Dostępu Uzależniona (DAC), Obowiązkowa (MAC), oparta na Rolach (RBAC) czy na Atrybutach (ABAC).

\sphinxAtStartPar
PostgreSQL oferuje narzędzia do zarządzania limitami systemowymi i kontrolą dostępu. Administratorzy mogą ustawiać parametry takie jak maksymalna liczba połączeń, limity pamięci, maksymalny rozmiar pliku danych czy wielkość tabeli. W zakresie kontroli dostępu PostgreSQL zapewnia mechanizmy uwierzytelniania i autoryzacji. Administratorzy mogą tworzyć role i nadawać uprawnienia dotyczące baz danych, schematów, tabel i kolumn. PostgreSQL obsługuje uwierzytelnianie oparte na hasłach i certyfikatach SSL, umożliwiając skuteczne zarządzanie bezpieczeństwem i poufnością danych.


\section{Testowanie wydajności sprzętu na poziomie OS}
\label{\detokenize{rozdzial2/index:testowanie-wydajnosci-sprzetu-na-poziomie-os}}
\sphinxAtStartPar
Testy wydajności kluczowych komponentów sprzętowych na poziomie systemu operacyjnego są niezbędne do optymalizacji działania baz danych. Obejmują oceny pamięci RAM, procesora (CPU) oraz dysków twardych (HDD) i SSD — elementów mających największy wpływ na szybkość i efektywność systemu. Analiza wyników pomaga wskazać elementy wymagające modernizacji lub optymalizacji, co pozwala podnieść ogólną wydajność systemu bazodanowego, niezależnie od używanego oprogramowania.

\sphinxAtStartPar
Testy pamięci RAM pozwalają zmierzyć jej szybkość i stabilność, co przekłada się na wydajność bazy danych. W tym celu często stosuje się narzędzia takie jak MemTest86.

\sphinxAtStartPar
Testy procesora oceniają jego moc obliczeniową i zdolność do przetwarzania zapytań. Popularnym programem jest Cinebench R23.

\sphinxAtStartPar
Testy dysków sprawdzają szybkość operacji odczytu i zapisu, co jest kluczowe, ponieważ baza danych przechowuje dane na nośnikach dyskowych. Do pomiarów wykorzystuje się narzędzia takie jak CrystalDiskMark 8 czy Acronis Drive Monitor.


\section{Podsumowanie}
\label{\detokenize{rozdzial2/index:podsumowanie}}
\sphinxAtStartPar
W pracy przedstawiono kluczowe zagadnienia związane z zarządzaniem bazami danych, w tym rodzaje replikacji, metody kontroli dostępu użytkowników, limity systemowe oraz znaczenie testów wydajności komponentów sprzętowych. Omówiono zalety i wady replikacji, takie jak zwiększenie dostępności czy ryzyko niespójności danych. Scharakteryzowano mechanizmy uwierzytelniania i autoryzacji, które zapewniają bezpieczeństwo informacji, oraz wskazano, jak limity zasobów wpływają na działanie systemu. Zwrócono także uwagę na rolę testów pamięci RAM, procesora i dysków w optymalizacji wydajności środowiska bazodanowego. Całość podkreśla znaczenie świadomego projektowania i utrzymywania infrastruktury baz danych w celu zapewnienia jej niezawodności, bezpieczeństwa i wysokiej efektywności pracy.


\section{Bibliografia}
\label{\detokenize{rozdzial2/index:bibliografia}}
\sphinxAtStartPar
{[}1{]} PostgreSQL Documentation \textendash{} Performance Tips
\sphinxurl{https://www.postgresql.org/docs/current/performance-tips.html}

\sphinxAtStartPar
{[}2{]} SQLite Documentation \textendash{} Query Optimizer Overview
\sphinxurl{https://sqlite.org/optoverview.html}

\sphinxAtStartPar
{[}3{]} F. Hecht, Scaling Database Systems
\sphinxurl{https://www.cockroachlabs.com/docs/stable/scaling-your-database.html}

\sphinxAtStartPar
{[}4{]} DigitalOcean, How To Optimize Queries and Tables in PostgreSQL
\sphinxurl{https://www.digitalocean.com/community/tutorials/how-to-optimize-queries-and-tables-in-postgresql}

\sphinxAtStartPar
{[}5{]} PostgreSQL Documentation \textendash{} High Availability, Load Balancing, and Replication
\sphinxurl{https://www.postgresql.org/docs/current/different-replication-solutions.html}

\sphinxAtStartPar
{[}6{]} SQLite Documentation \textendash{} How Indexes Work
\sphinxurl{https://www.sqlite.org/queryplanner.html}

\sphinxAtStartPar
{[}7{]} Redgate, The Importance of Database Performance Testing
\sphinxurl{https://www.red-gate.com/simple-talk/sql/performance/the-importance-of-database-performance-testing/}

\sphinxAtStartPar
{[}8{]} Materiały kursowe przedmiotu „Bazy Danych”, Politechnika Wrocławska, Piotr Czaja.

\sphinxstepscope


\chapter{Projektowanie bazy danych \sphinxhyphen{} modele}
\label{\detokenize{rozdzial3/index:projektowanie-bazy-danych-modele}}\label{\detokenize{rozdzial3/index::doc}}\begin{quote}\begin{description}
\sphinxlineitem{author}
\sphinxAtStartPar
Mateusz Brokos, Szymon Blatkowski

\end{description}\end{quote}


\section{Wprowadzenie}
\label{\detokenize{rozdzial3/index:wprowadzenie}}
\sphinxAtStartPar
Prowadzący: Piotr Czaja

\sphinxAtStartPar
Kurs: Bazy Danych 1

\sphinxAtStartPar
Celem tego raportu jest przedstawienie pełnego procesu projektowania i optymalizacji bazy danych wspierającej rejestrację oraz obsługę wizyt lekarskich w przychodni.


\section{Model Konceptualny}
\label{\detokenize{rozdzial3/index:model-konceptualny}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+      1       *      +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
  |  Pacjent  |\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}|   Wizyta  |
  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+                     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
  | PK: id    |                     | PK: id    |
  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+                     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
       \PYGZca{}  \PYGZbs{}
       |   \PYGZbs{}
umawia się   \PYGZbs{}
  (1..*)      v
  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
  |  Lekarz   |
  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
  | PK: id    |
  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{sphinxVerbatim}
\begin{description}
\sphinxlineitem{Legenda}\begin{itemize}
\item {} 
\sphinxAtStartPar
Pacjent \textendash{} może umawiać wiele wizyt (1..*)

\item {} 
\sphinxAtStartPar
Wizyta \textendash{} dotyczy jednego pacjenta i jednego lekarza

\item {} 
\sphinxAtStartPar
Lekarz \textendash{} może prowadzić wiele wizyt (1..*)

\end{itemize}

\end{description}


\section{Model Logiczny}
\label{\detokenize{rozdzial3/index:model-logiczny}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
|   Pacjent   |       |   Lekarz   |       |   Wizyta  |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
| PK: patient\PYGZus{}id    | PK: doctor\PYGZus{}id   | PK: visit\PYGZus{}id    |
| first\PYGZus{}name        | first\PYGZus{}name      | patient\PYGZus{}id (FK) |
| last\PYGZus{}name         | last\PYGZus{}name       | doctor\PYGZus{}id  (FK) |
| pesel             | specialization\PYGZus{}id (FK)| visit\PYGZus{}datetime |
| birth\PYGZus{}date        +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+| status         |
| email             | specialization\PYGZus{}id \(\rightarrow\) Specialization | notes |
| phone             |                |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{sphinxVerbatim}

\sphinxAtStartPar
Dodatkowa encja:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
|  Specialization    |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
| PK: specialization\PYGZus{}id |
| name               |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{sphinxVerbatim}
\begin{description}
\sphinxlineitem{Relacje}\begin{itemize}
\item {} 
\sphinxAtStartPar
Visit.patient\_id \(\rightarrow\) Patient.patient\_id (1:N)

\item {} 
\sphinxAtStartPar
Visit.doctor\_id  \(\rightarrow\) Doctor.doctor\_id  (1:N)

\item {} 
\sphinxAtStartPar
Doctor.specialization\_id \(\rightarrow\) Specialization.specialization\_id (1:N)

\end{itemize}

\end{description}


\section{Model Fizyczny}
\label{\detokenize{rozdzial3/index:model-fizyczny}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Specialization}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{specialization\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{name}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{UNIQUE}
\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Doctor}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{doctor\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{first\PYGZus{}name}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{last\PYGZus{}name}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{license\PYGZus{}number}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{UNIQUE}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{specialization\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INTEGER}
\PYG{+w}{        }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Specialization}\PYG{p}{(}\PYG{n}{specialization\PYGZus{}id}\PYG{p}{)}
\PYG{+w}{        }\PYG{k}{ON}\PYG{+w}{ }\PYG{k}{UPDATE}\PYG{+w}{ }\PYG{k}{CASCADE}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{k}{DELETE}\PYG{+w}{ }\PYG{k}{SET}\PYG{+w}{ }\PYG{k}{NULL}
\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Patient}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{patient\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{first\PYGZus{}name}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{last\PYGZus{}name}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{pesel}\PYG{+w}{ }\PYG{n+nb}{CHAR}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{UNIQUE}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{birth\PYGZus{}date}\PYG{+w}{ }\PYG{n+nb}{DATE}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{email}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{phone}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Visit}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{visit\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{patient\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INTEGER}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}
\PYG{+w}{        }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Patient}\PYG{p}{(}\PYG{n}{patient\PYGZus{}id}\PYG{p}{)}
\PYG{+w}{        }\PYG{k}{ON}\PYG{+w}{ }\PYG{k}{UPDATE}\PYG{+w}{ }\PYG{k}{CASCADE}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{k}{DELETE}\PYG{+w}{ }\PYG{k}{CASCADE}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{doctor\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INTEGER}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}
\PYG{+w}{        }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Doctor}\PYG{p}{(}\PYG{n}{doctor\PYGZus{}id}\PYG{p}{)}
\PYG{+w}{        }\PYG{k}{ON}\PYG{+w}{ }\PYG{k}{UPDATE}\PYG{+w}{ }\PYG{k}{CASCADE}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{k}{DELETE}\PYG{+w}{ }\PYG{k}{CASCADE}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{visit\PYGZus{}datetime}\PYG{+w}{ }\PYG{k}{TIMESTAMP}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{status}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{notes}\PYG{+w}{ }\PYG{n+nb}{TEXT}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Przykładowe rekordy}
\label{\detokenize{rozdzial3/index:przykladowe-rekordy}}

\subsection{Tabela Specialization}
\label{\detokenize{rozdzial3/index:tabela-specialization}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
specialization\_id
&\sphinxstyletheadfamily 
\sphinxAtStartPar
name
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Internista
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
Pediatra
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
Kardiolog
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Tabela Doctor}
\label{\detokenize{rozdzial3/index:tabela-doctor}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
doctor\_id
&\sphinxstyletheadfamily 
\sphinxAtStartPar
first\_name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
last\_name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
license\_number
&\sphinxstyletheadfamily 
\sphinxAtStartPar
specialization\_id
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Anna
&
\sphinxAtStartPar
Nowak
&
\sphinxAtStartPar
PWZ123456
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
Paweł
&
\sphinxAtStartPar
Kowalski
&
\sphinxAtStartPar
PWZ654321
&
\sphinxAtStartPar
2
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Tabela Patient}
\label{\detokenize{rozdzial3/index:tabela-patient}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
patient\_id
&\sphinxstyletheadfamily 
\sphinxAtStartPar
first\_name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
last\_name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
pesel
&\sphinxstyletheadfamily 
\sphinxAtStartPar
birth\_date
&\sphinxstyletheadfamily 
\sphinxAtStartPar
email
&\sphinxstyletheadfamily 
\sphinxAtStartPar
phone
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Maria
&
\sphinxAtStartPar
Wiśniewska
&
\sphinxAtStartPar
90010112345
&
\sphinxAtStartPar
1990\sphinxhyphen{}01\sphinxhyphen{}01
&
\sphinxAtStartPar
\sphinxhref{mailto:maria@example.com}{maria@example.com}
&
\sphinxAtStartPar
+48123123123
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
Tomasz
&
\sphinxAtStartPar
Dąbrowski
&
\sphinxAtStartPar
85050554321
&
\sphinxAtStartPar
1985\sphinxhyphen{}05\sphinxhyphen{}05
&
\sphinxAtStartPar
\sphinxhref{mailto:tomasz@example.com}{tomasz@example.com}
&
\sphinxAtStartPar
+48987654321
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Tabela Visit}
\label{\detokenize{rozdzial3/index:tabela-visit}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
visit\_id
&\sphinxstyletheadfamily 
\sphinxAtStartPar
patient\_id
&\sphinxstyletheadfamily 
\sphinxAtStartPar
doctor\_id
&\sphinxstyletheadfamily 
\sphinxAtStartPar
visit\_datetime
&\sphinxstyletheadfamily 
\sphinxAtStartPar
status
&\sphinxstyletheadfamily 
\sphinxAtStartPar
notes
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
2025\sphinxhyphen{}06\sphinxhyphen{}01 10:30:00
&
\sphinxAtStartPar
zaplanowana
&
\sphinxAtStartPar
“Pierwsza wizyta”
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
2025\sphinxhyphen{}06\sphinxhyphen{}02 14:00:00
&
\sphinxAtStartPar
odbyta
&
\sphinxAtStartPar
“Kontrola po leczeniu”
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\chapter{Analiza Bazy danych i optymalizacja zapytań}
\label{\detokenize{rozdzial4/index:analiza-bazy-danych-i-optymalizacja-zapytan}}\label{\detokenize{rozdzial4/index::doc}}

\section{Analiza normalizacji}
\label{\detokenize{rozdzial4/index:analiza-normalizacji}}
\sphinxAtStartPar
Model logiczny jest w 3NF:
\sphinxhyphen{} Każda tabela ma pojedynczy klucz główny.
\sphinxhyphen{} Atrybuty niekluczowe zależą wyłącznie od klucza.
\sphinxhyphen{} Brak zależności przechodnich (specjalizacja wydzielona osobno).


\section{Potencjalne problemy wydajnościowe}
\label{\detokenize{rozdzial4/index:potencjalne-problemy-wydajnosciowe}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Brak indeksów poza kluczami głównymi.

\item {} 
\sphinxAtStartPar
Częste filtrowanie po \sphinxtitleref{visit\_datetime} i \sphinxtitleref{doctor\_id} wymaga skanów.

\end{itemize}


\section{Strategie optymalizacji}
\label{\detokenize{rozdzial4/index:strategie-optymalizacji}}
\sphinxAtStartPar
\sphinxstylestrong{1. Indeksy}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{INDEX}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}visit\PYGZus{}patient}\PYG{+w}{    }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{Visit}\PYG{p}{(}\PYG{n}{patient\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{INDEX}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}visit\PYGZus{}doctor}\PYG{+w}{     }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{Visit}\PYG{p}{(}\PYG{n}{doctor\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{INDEX}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}visit\PYGZus{}date}\PYG{+w}{       }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{Visit}\PYG{p}{(}\PYG{n}{visit\PYGZus{}datetime}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{INDEX}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}visit\PYGZus{}doc\PYGZus{}date}\PYG{+w}{   }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{Visit}\PYG{p}{(}\PYG{n}{doctor\PYGZus{}id}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{visit\PYGZus{}datetime}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{2. Partycjonowanie}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Partycjonuj tabelę \sphinxtitleref{Visit} według miesiąca \sphinxtitleref{visit\_datetime}.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{3. Widoki materializowane}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{n}{MATERIALIZED}\PYG{+w}{ }\PYG{k}{VIEW}\PYG{+w}{ }\PYG{n}{mv\PYGZus{}daily\PYGZus{}visits}\PYG{+w}{ }\PYG{k}{AS}
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n+nb}{DATE}\PYG{p}{(}\PYG{n}{visit\PYGZus{}datetime}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{k}{day}\PYG{p}{,}
\PYG{+w}{       }\PYG{n}{doctor\PYGZus{}id}\PYG{p}{,}
\PYG{+w}{       }\PYG{k}{COUNT}\PYG{p}{(}\PYG{o}{*}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{n}{total}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{Visit}
\PYG{k}{GROUP}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{k}{day}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{doctor\PYGZus{}id}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{4. Optymalizacja zapytań}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Używaj \sphinxtitleref{EXPLAIN (ANALYZE, BUFFERS)} do analizy planów.

\item {} 
\sphinxAtStartPar
Unikaj \sphinxtitleref{SELECT *}, wybieraj konkretne kolumny.

\end{itemize}

\sphinxAtStartPar
Przykład optymalizacji:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Przed optymalizacją:}
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{first\PYGZus{}name}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{last\PYGZus{}name}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{COUNT}\PYG{p}{(}\PYG{o}{*}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{n}{cnt}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{Visit}\PYG{+w}{ }\PYG{n}{v}
\PYG{k}{JOIN}\PYG{+w}{ }\PYG{n}{Patient}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{.}\PYG{n}{patient\PYGZus{}id}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{patient\PYGZus{}id}
\PYG{k}{WHERE}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{.}\PYG{n}{visit\PYGZus{}datetime}\PYG{+w}{ }\PYG{k}{BETWEEN}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}2025\PYGZhy{}06\PYGZhy{}01\PYGZsq{}}\PYG{+w}{ }\PYG{k}{AND}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}2025\PYGZhy{}12\PYGZhy{}31\PYGZsq{}}
\PYG{k}{GROUP}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{first\PYGZus{}name}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{last\PYGZus{}name}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Po (z indeksem na visit\PYGZus{}datetime):}
\PYG{k}{EXPLAIN}\PYG{+w}{ }\PYG{k}{ANALYZE}
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{first\PYGZus{}name}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{last\PYGZus{}name}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{COUNT}\PYG{p}{(}\PYG{o}{*}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{n}{cnt}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{Visit}\PYG{+w}{ }\PYG{n}{v}
\PYG{k}{JOIN}\PYG{+w}{ }\PYG{n}{Patient}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{.}\PYG{n}{patient\PYGZus{}id}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{patient\PYGZus{}id}
\PYG{k}{WHERE}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{.}\PYG{n}{visit\PYGZus{}datetime}\PYG{+w}{ }\PYG{k}{BETWEEN}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}2025\PYGZhy{}06\PYGZhy{}01\PYGZsq{}}\PYG{+w}{ }\PYG{k}{AND}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}2025\PYGZhy{}12\PYGZhy{}31\PYGZsq{}}
\PYG{k}{GROUP}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{first\PYGZus{}name}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{last\PYGZus{}name}
\PYG{k}{LIMIT}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Prezentacja skryptów wspomagających}
\label{\detokenize{rozdzial4/index:prezentacja-skryptow-wspomagajacych}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{sqlite3}
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{pandas}\PYG{+w}{ }\PYG{k}{as}\PYG{+w}{ }\PYG{n+nn}{pd}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ClinicDB}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Klasa do obsługi bazy danych kliniki SQLite z wykorzystaniem Pandas.}

\PYG{l+s+sd}{    Atrybuty:}
\PYG{l+s+sd}{        conn (sqlite3.Connection): Połączenie z bazą.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{db\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clinic.db}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Inicjalizuje połączenie z bazą.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{conn} \PYG{o}{=} \PYG{n}{sqlite3}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{n}{db\PYGZus{}path}\PYG{p}{)}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{get\PYGZus{}all\PYGZus{}patients}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Zwraca DataFrame ze wszystkimi pacjentami.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{return} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}sql}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SELECT * FROM Patient}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{conn}\PYG{p}{)}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{find\PYGZus{}patients\PYGZus{}by\PYGZus{}name}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name\PYGZus{}part}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Wyszukuje pacjentów po fragmencie imienia/nazwiska.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{q} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SELECT * FROM Patient WHERE first\PYGZus{}name LIKE ? OR last\PYGZus{}name LIKE ?}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{k}{return} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}sql}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{conn}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{name\PYGZus{}part}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{.}\PYG{o}{.} \PYG{n}{code}\PYG{o}{\PYGZhy{}}\PYG{n}{block}\PYG{p}{:}\PYG{p}{:} \PYG{n}{python}

    \PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{sqlite3}
    \PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{time}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{measure\PYGZus{}sqlite\PYGZus{}queries}\PYG{p}{(}\PYG{n}{db\PYGZus{}path}\PYG{p}{,} \PYG{n}{queries}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Mierzy czas wykonania zapytań SQL na SQLite.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{conn} \PYG{o}{=} \PYG{n}{sqlite3}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{n}{db\PYGZus{}path}\PYG{p}{)}
        \PYG{n}{cur} \PYG{o}{=} \PYG{n}{conn}\PYG{o}{.}\PYG{n}{cursor}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{q} \PYG{o+ow}{in} \PYG{n}{queries}\PYG{p}{:}
            \PYG{n}{t0} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{cur}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
            \PYG{n}{rows} \PYG{o}{=} \PYG{n}{cur}\PYG{o}{.}\PYG{n}{fetchall}\PYG{p}{(}\PYG{p}{)}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Czas: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t0}\PYG{l+s+si}{:}\PYG{l+s+s2}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{s, wierszy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{conn}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{o}{.}\PYG{o}{.} \PYG{n}{code}\PYG{o}{\PYGZhy{}}\PYG{n}{block}\PYG{p}{:}\PYG{p}{:} \PYG{n}{python}

    \PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{sqlite3}
    \PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{pandas}\PYG{+w}{ }\PYG{k}{as}\PYG{+w}{ }\PYG{n+nn}{pd}
    \PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot}\PYG{+w}{ }\PYG{k}{as}\PYG{+w}{ }\PYG{n+nn}{plt}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{generate\PYGZus{}reports}\PYG{p}{(}\PYG{n}{db\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{clinic.db}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Generuje raporty i wykresy z danych kliniki.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{conn} \PYG{o}{=} \PYG{n}{sqlite3}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{n}{db\PYGZus{}path}\PYG{p}{)}
        \PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}sql}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SELECT * FROM Visit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{conn}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} ... wykresy ...}
        \PYG{n}{conn}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Wnioski}
\label{\detokenize{rozdzial4/index:wnioski}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Model w 3NF minimalizuje redundancję i ułatwia utrzymanie.

\item {} 
\sphinxAtStartPar
Indeksy i widoki materializowane znacząco przyspieszą zapytania analityczne.

\item {} 
\sphinxAtStartPar
Regularne analizowanie planów (\sphinxtitleref{EXPLAIN ANALYZE}) pozwoli wychwycić wąskie gardła.

\end{itemize}

\sphinxstepscope


\chapter{Podsumowanie}
\label{\detokenize{rozdzial5/index:podsumowanie}}\label{\detokenize{rozdzial5/index::doc}}
\sphinxAtStartPar
Przeprowadzony projekt oraz analiza wykazały, że zaprojektowana baza danych spełnia założone wymagania funkcjonalne i wydajnościowe. Model danych został znormalizowany do trzeciej postaci normalnej, co pozwoliło ograniczyć redundancję i uprościć strukturę tabel. Implementacja indeksów oraz widoków materializowanych przyczyniła się do poprawy efektywności wykonywania zapytań. Dodatkowo zastosowanie narzędzi do dokumentacji i generowania raportów umożliwiło przygotowanie przejrzystego zestawienia kodów źródłowych oraz wizualizacji danych. Wyniki testów potwierdziły prawidłowe działanie systemu i jego zgodność ze specyfikacją założoną na etapie projektowania.


\section{Spis repozytoriów}
\label{\detokenize{rozdzial5/index:spis-repozytoriow}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Sprawozdanie i kod: \sphinxurl{https://github.com/sajmon337/Raport\_bazy.git}

\item {} 
\sphinxAtStartPar
Przegląd literatury: \sphinxurl{https://github.com/Broksonn/Wydajnosc\_Skalowanie\_i\_Replikacja.git}

\end{enumerate}



\renewcommand{\indexname}{Index}
\printindex
\end{document}